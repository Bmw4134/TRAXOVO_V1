"""
Driver Module Controller

This module provides routes and functionality for the Driver module,
including daily reports, attendance tracking, and driver management.
"""

import os
import json
import logging
from datetime import datetime, timedelta
from flask import Blueprint, render_template, request, jsonify, redirect, url_for, flash, session, current_app, send_file
from flask_login import login_required, current_user
from werkzeug.utils import secure_filename

# Import activity logger
from utils.activity_logger import (
    log_navigation, log_document_upload, log_report_export,
    log_feature_usage, log_search
)

# Import database
from app import db

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize blueprint
driver_module_bp = Blueprint('driver_module', __name__, url_prefix='/drivers')

# Constants
UPLOAD_FOLDER = os.path.join('uploads', 'driver_files')
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

EXPORTS_FOLDER = os.path.join('exports', 'driver_reports')
os.makedirs(EXPORTS_FOLDER, exist_ok=True)

ALLOWED_EXTENSIONS = {'csv', 'xlsx', 'pdf'}

# Helper functions
def allowed_file(filename):
    """Check if file has an allowed extension"""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def get_drivers():
    """
    Get driver data from the database
    Returns a list of driver dictionaries with attendance metrics
    """
    try:
        # Import the models
        from models.driver_attendance import DriverAttendance, AttendanceRecord
        from sqlalchemy import func
        
        # Query all active drivers from the database
        drivers = DriverAttendance.query.filter_by(is_active=True).all()
        
        # Start building the result list
        result = []
        
        # Get the current date for "last active" calculation
        current_date = datetime.now().date()
        
        # For each driver, gather attendance statistics
        for driver in drivers:
            # Get attendance records for the last 30 days
            thirty_days_ago = current_date - timedelta(days=30)
            records = AttendanceRecord.query.filter_by(driver_id=driver.id).filter(
                AttendanceRecord.date >= thirty_days_ago,
                AttendanceRecord.date <= current_date
            ).all()
            
            # Calculate attendance metrics
            late_count = sum(1 for r in records if r.late_start)
            early_end_count = sum(1 for r in records if r.early_end)
            not_on_job_count = sum(1 for r in records if r.not_on_job)
            
            # Calculate last active date
            last_record = AttendanceRecord.query.filter_by(driver_id=driver.id).order_by(
                AttendanceRecord.date.desc()
            ).first()
            
            last_active = last_record.date.strftime('%Y-%m-%d') if last_record else "N/A"
            
            # Calculate an attendance score (percentage of days without issues)
            total_records = len(records)
            problem_records = late_count + early_end_count + not_on_job_count
            attendance_score = 100
            if total_records > 0:
                attendance_score = int(round((total_records - problem_records) / total_records * 100))
            
            # Get the most frequent job site
            job_site = "Unknown"
            if records:
                job_sites = {}
                for r in records:
                    if r.assigned_job and r.assigned_job.name:
                        site = r.assigned_job.name
                        job_sites[site] = job_sites.get(site, 0) + 1
                
                if job_sites:
                    job_site = max(job_sites.items(), key=lambda x: x[1])[0]
            
            # Get the most recent vehicle/asset
            vehicle = "None"
            if records:
                vehicles = [r.asset_id for r in records if r.asset_id]
                if vehicles:
                    vehicle = vehicles[0]  # Most recent vehicle
            
            # Add driver to result list
            result.append({
                'id': str(driver.id),
                'name': driver.full_name,
                'employee_id': driver.employee_id,
                'status': 'Active' if driver.is_active else 'Inactive',
                'region': driver.division,
                'vehicle': vehicle,
                'job_site': job_site,
                'attendance_score': attendance_score,
                'late_count': late_count,
                'early_end_count': early_end_count,
                'not_on_job_count': not_on_job_count,
                'last_active': last_active
            })
        
        return result
    except Exception as e:
        # Log the error and return sample data as fallback
        logger.error(f"Error fetching driver data: {str(e)}")
        # Return an empty list if there's an error
        return []

def get_daily_report(date_str=None):
    """
    Get daily report data from the database
    Args:
        date_str: Date string in YYYY-MM-DD format, defaults to today
        
    Returns:
        dict: Daily report data
    """
    try:
        # Import models
        from models.driver_attendance import DriverAttendance, AttendanceRecord, JobSiteAttendance
        from sqlalchemy import func
        
        # Parse date or use today
        report_date = datetime.now().date()
        if date_str:
            try:
                report_date = datetime.strptime(date_str, '%Y-%m-%d').date()
            except ValueError:
                logger.error(f"Invalid date format: {date_str}")
        
        # Get all attendance records for the specified date
        records = AttendanceRecord.query.filter(
            AttendanceRecord.date == report_date
        ).all()
        
        # If no records found, return empty report structure
        if not records:
            logger.warning(f"No attendance records found for {report_date}")
            return {
                'date': report_date.strftime('%Y-%m-%d'),
                'total_drivers': 0,
                'on_time': 0,
                'late_start': 0,
                'early_end': 0,
                'not_on_job': 0,
                'regions': [],
                'active_job_sites': 0,
                'late_drivers': [],
                'early_end_drivers': [],
                'not_on_job_drivers': []
            }
        
        # Count metrics
        total_drivers = len(records)
        late_start_count = sum(1 for r in records if r.late_start)
        early_end_count = sum(1 for r in records if r.early_end)
        not_on_job_count = sum(1 for r in records if r.not_on_job)
        on_time_count = total_drivers - (late_start_count + early_end_count + not_on_job_count)
        
        # Get unique regions and job sites
        regions = list(set(d.driver_attendance.division for d in records if d.driver_attendance and d.driver_attendance.division))
        job_sites = set()
        for r in records:
            if r.assigned_job and r.assigned_job.name:
                job_sites.add(r.assigned_job.name)
        
        # Get late drivers
        late_drivers = []
        for record in records:
            if record.late_start and record.driver_attendance:
                driver = record.driver_attendance
                job_site_name = record.assigned_job.name if record.assigned_job else "Unknown"
                
                # Calculate minutes late
                minutes_late = 0
                if record.expected_start_time and record.actual_start_time:
                    time_diff = record.actual_start_time - record.expected_start_time
                    minutes_late = int(time_diff.total_seconds() / 60)
                
                # Format times for display
                scheduled_start = record.expected_start_time.strftime('%I:%M %p') if record.expected_start_time else "Unknown"
                actual_start = record.actual_start_time.strftime('%I:%M %p') if record.actual_start_time else "Unknown"
                
                late_drivers.append({
                    'id': str(driver.id),
                    'name': driver.full_name,
                    'employee_id': driver.employee_id,
                    'region': driver.division,
                    'job_site': job_site_name,
                    'scheduled_start': scheduled_start,
                    'actual_start': actual_start,
                    'minutes_late': minutes_late,
                    'vehicle': record.asset_id or "Unknown",
                    'supervisor': "Not Available"  # Supervisor data not available in current model
                })
        
        # Get early end drivers
        early_end_drivers = []
        for record in records:
            if record.early_end and record.driver_attendance:
                driver = record.driver_attendance
                job_site_name = record.assigned_job.name if record.assigned_job else "Unknown"
                
                # Calculate minutes early
                minutes_early = 0
                if record.expected_end_time and record.actual_end_time:
                    time_diff = record.expected_end_time - record.actual_end_time
                    minutes_early = int(time_diff.total_seconds() / 60)
                
                # Format times for display
                scheduled_end = record.expected_end_time.strftime('%I:%M %p') if record.expected_end_time else "Unknown"
                actual_end = record.actual_end_time.strftime('%I:%M %p') if record.actual_end_time else "Unknown"
                
                early_end_drivers.append({
                    'id': str(driver.id),
                    'name': driver.full_name,
                    'employee_id': driver.employee_id,
                    'region': driver.division,
                    'job_site': job_site_name,
                    'scheduled_end': scheduled_end,
                    'actual_end': actual_end,
                    'minutes_early': minutes_early,
                    'vehicle': record.asset_id or "Unknown",
                    'supervisor': "Not Available"  # Supervisor data not available in current model
                })
        
        # Get not on job drivers
        not_on_job_drivers = []
        for record in records:
            if record.not_on_job and record.driver_attendance:
                driver = record.driver_attendance
                
                # Get assigned and actual job sites
                assigned_site = record.assigned_job.name if record.assigned_job else "Unknown"
                actual_site = record.actual_job.name if record.actual_job else "Unknown"
                
                scheduled_start = record.expected_start_time.strftime('%I:%M %p') if record.expected_start_time else "Unknown"
                
                not_on_job_drivers.append({
                    'id': str(driver.id),
                    'name': driver.full_name,
                    'employee_id': driver.employee_id,
                    'region': driver.division,
                    'job_site': assigned_site,
                    'scheduled_start': scheduled_start,
                    'vehicle': record.asset_id or "Unknown",
                    'supervisor': "Not Available",  # Supervisor data not available in current model
                    'reason': f"Driver at {actual_site} instead of {assigned_site}",
                    'notes': record.notes or "No additional notes"
                })
        
        # Build and return the report
        return {
            'date': report_date.strftime('%Y-%m-%d'),
            'total_drivers': total_drivers,
            'on_time': on_time_count,
            'late_start': late_start_count,
            'early_end': early_end_count,
            'not_on_job': not_on_job_count,
            'regions': regions,
            'active_job_sites': len(job_sites),
            'late_drivers': late_drivers,
            'early_end_drivers': early_end_drivers,
            'not_on_job_drivers': not_on_job_drivers
        }
        
    except Exception as e:
        logger.error(f"Error fetching daily report data: {str(e)}")
        # Return a basic structure in case of error
        return {
            'date': datetime.now().strftime('%Y-%m-%d'),
            'total_drivers': 0,
            'on_time': 0,
            'late_start': 0,
            'early_end': 0,
            'not_on_job': 0,
            'regions': [],
            'active_job_sites': 0,
            'late_drivers': [],
            'early_end_drivers': [],
            'not_on_job_drivers': []
        }

def get_attendance_stats(days=30):
    """
    Get attendance statistics from the database for dashboard
    
    Args:
        days (int): Number of days to include in statistics
        
    Returns:
        dict: Attendance statistics
    """
    try:
        # Import models
        from models.driver_attendance import DriverAttendance, AttendanceRecord, JobSiteAttendance
        from sqlalchemy import func, desc
        
        # Calculate date range
        today = datetime.now().date()
        start_date = today - timedelta(days=days-1)
        
        # Get all dates in range for consistent x-axis even if no data for some days
        dates = [(today - timedelta(days=i)).strftime('%Y-%m-%d') for i in range(days-1, -1, -1)]
        
        # Query to get attendance data grouped by date
        date_stats = {}
        for date_str in dates:
            # Initialize with zeros
            date_stats[date_str] = {
                'total': 0, 
                'on_time': 0, 
                'late_start': 0, 
                'early_end': 0, 
                'not_on_job': 0
            }
        
        # Get actual records from database
        records = AttendanceRecord.query.filter(
            AttendanceRecord.date.between(start_date, today)
        ).all()
        
        # Process records to build statistics
        for record in records:
            date_str = record.date.strftime('%Y-%m-%d')
            if date_str in date_stats:
                date_stats[date_str]['total'] += 1
                
                if record.late_start:
                    date_stats[date_str]['late_start'] += 1
                
                if record.early_end:
                    date_stats[date_str]['early_end'] += 1
                
                if record.not_on_job:
                    date_stats[date_str]['not_on_job'] += 1
                
                # Count on-time as those without any flags
                if not (record.late_start or record.early_end or record.not_on_job):
                    date_stats[date_str]['on_time'] += 1
        
        # Calculate on-time percentages and count arrays
        on_time_percentages = []
        late_start_counts = []
        early_end_counts = []
        not_on_job_counts = []
        
        for date_str in dates:
            stats = date_stats[date_str]
            total = stats['total']
            if total > 0:
                on_time_pct = round((stats['on_time'] / total) * 100)
            else:
                on_time_pct = 100  # Default to 100% if no data
            
            on_time_percentages.append(on_time_pct)
            late_start_counts.append(stats['late_start'])
            early_end_counts.append(stats['early_end'])
            not_on_job_counts.append(stats['not_on_job'])
        
        # Get job site statistics
        job_sites = []
        job_site_query = db.session.query(
            JobSiteAttendance.id,
            JobSiteAttendance.name,
            func.count(AttendanceRecord.id).label('total_count')
        ).join(
            AttendanceRecord, 
            AttendanceRecord.assigned_job_id == JobSiteAttendance.id
        ).filter(
            AttendanceRecord.date.between(start_date, today)
        ).group_by(
            JobSiteAttendance.id
        ).order_by(
            desc('total_count')
        ).limit(5).all()
        
        for site_id, site_name, driver_count in job_site_query:
            # Calculate on-time percentage for this job site
            on_time_records = db.session.query(func.count(AttendanceRecord.id)).filter(
                AttendanceRecord.assigned_job_id == site_id,
                AttendanceRecord.date.between(start_date, today),
                ~(AttendanceRecord.late_start | AttendanceRecord.early_end | AttendanceRecord.not_on_job)
            ).scalar() or 0
            
            on_time_percentage = round((on_time_records / driver_count) * 100) if driver_count > 0 else 100
            
            job_sites.append({
                'id': str(site_id),
                'name': site_name,
                'on_time_percentage': on_time_percentage,
                'driver_count': driver_count
            })
        
        # Get region statistics
        regions = []
        region_query = db.session.query(
            DriverAttendance.division,
            func.count(DriverAttendance.id.distinct()).label('driver_count')
        ).join(
            AttendanceRecord,
            AttendanceRecord.driver_id == DriverAttendance.id
        ).filter(
            AttendanceRecord.date.between(start_date, today),
            DriverAttendance.division.isnot(None)
        ).group_by(
            DriverAttendance.division
        ).all()
        
        for division, driver_count in region_query:
            # Calculate on-time percentage for this region
            total_records = db.session.query(func.count(AttendanceRecord.id)).join(
                DriverAttendance,
                AttendanceRecord.driver_id == DriverAttendance.id
            ).filter(
                DriverAttendance.division == division,
                AttendanceRecord.date.between(start_date, today)
            ).scalar() or 0
            
            on_time_records = db.session.query(func.count(AttendanceRecord.id)).join(
                DriverAttendance,
                AttendanceRecord.driver_id == DriverAttendance.id
            ).filter(
                DriverAttendance.division == division,
                AttendanceRecord.date.between(start_date, today),
                ~(AttendanceRecord.late_start | AttendanceRecord.early_end | AttendanceRecord.not_on_job)
            ).scalar() or 0
            
            on_time_percentage = round((on_time_records / total_records) * 100) if total_records > 0 else 100
            
            region_name = division
            if division == 'DFW':
                region_name = 'Dallas-Fort Worth'
            elif division == 'HOU':
                region_name = 'Houston'
            elif division == 'WTX':
                region_name = 'West Texas'
            
            regions.append({
                'id': division,
                'name': region_name,
                'on_time_percentage': on_time_percentage,
                'driver_count': driver_count
            })
        
        # Return the complete stats package
        return {
            'dates': dates,
            'on_time_percentages': on_time_percentages,
            'late_start_counts': late_start_counts,
            'early_end_counts': early_end_counts,
            'not_on_job_counts': not_on_job_counts,
            'job_sites': job_sites,
            'regions': regions
        }
        
    except Exception as e:
        logger.error(f"Error fetching attendance statistics: {str(e)}")
        # Return empty datasets if error occurs
        today = datetime.now()
        dates = [(today - timedelta(days=i)).strftime('%Y-%m-%d') for i in range(days-1, -1, -1)]
        
        # Return empty arrays matching the date range
        return {
            'dates': dates,
            'on_time_percentages': [0] * len(dates),
            'late_start_counts': [0] * len(dates),
            'early_end_counts': [0] * len(dates),
            'not_on_job_counts': [0] * len(dates),
            'job_sites': [],
            'regions': []
        }

# Routes
@driver_module_bp.route('/')
@login_required
def index():
    """Driver module home page"""
    log_navigation(current_user.id, 'driver_module.index')
    
    # Get summary statistics from the database
    drivers = get_drivers()
    driver_count = len(drivers)
    active_drivers = len([d for d in drivers if d['status'] == 'Active'])
    
    # Get daily report data
    daily_report = get_daily_report()
    late_count = len(daily_report['late_drivers'])
    early_end_count = len(daily_report['early_end_drivers'])
    not_on_job_count = len(daily_report['not_on_job_drivers'])
    
    # Calculate attendance score
    total_drivers = daily_report['total_drivers']
    on_time_drivers = daily_report['on_time']
    attendance_score = round((on_time_drivers / total_drivers) * 100) if total_drivers > 0 else 0
    
    return render_template('drivers/index.html',
                           driver_count=driver_count,
                           active_drivers=active_drivers,
                           late_count=late_count,
                           early_end_count=early_end_count,
                           not_on_job_count=not_on_job_count,
                           attendance_score=attendance_score)

@driver_module_bp.route('/daily_report')
@login_required
def daily_report():
    """Daily driver attendance report"""
    log_navigation(current_user.id, 'driver_module.daily_report')
    
    report_date = request.args.get('date', datetime.now().strftime('%Y-%m-%d'))
    report_data = get_daily_report(report_date)
    
    return render_template('drivers/daily_report.html', 
                          report=report_data, 
                          selected_date=report_date)

@driver_module_bp.route('/attendance_dashboard')
@login_required
def attendance_dashboard():
    """Attendance dashboard with trends and metrics"""
    log_navigation(current_user.id, 'driver_module.attendance_dashboard')
    
    # Get filter parameters
    days = request.args.get('days', 30, type=int)
    region = request.args.get('region', 'all')
    
    # Get data for the dashboard from the database
    stats = get_attendance_stats(days)
    drivers = get_drivers()
    
    active_drivers = len([d for d in drivers if d['status'] == 'Active'])
    attendance_score = stats['on_time_percentages'][-1] if stats['on_time_percentages'] else 0
    
    return render_template('drivers/attendance_dashboard.html',
                          stats=stats,
                          driver_count=active_drivers,
                          attendance_score=attendance_score,
                          selected_days=days,
                          selected_region=region)

@driver_module_bp.route('/driver_list')
@login_required
def driver_list():
    """List all drivers with filtering options"""
    log_navigation(current_user.id, 'driver_module.driver_list')
    
    # Get all drivers from the database
    drivers = get_drivers()
    
    # Handle filtering
    region = request.args.get('region')
    status = request.args.get('status')
    search = request.args.get('search', '').lower()
    
    if region:
        drivers = [d for d in drivers if d['region'] == region]
    
    if status:
        drivers = [d for d in drivers if d['status'] == status]
    
    if search:
        drivers = [d for d in drivers if search in d['name'].lower() or 
                   search in d['employee_id'].lower() or
                   search in d['job_site'].lower()]
        
        # Log search activity
        log_search(search, results_count=len(drivers), 
                  filters={'region': region, 'status': status})
    
    return render_template('drivers/driver_list.html', 
                          drivers=drivers,
                          filter_region=region,
                          filter_status=status,
                          search_query=search)

@driver_module_bp.route('/driver_detail/<driver_id>')
@login_required
def driver_detail(driver_id):
    """Driver detail page with attendance history"""
    try:
        log_navigation(current_user.id, f'driver_module.driver_detail.{driver_id}')
        
        # Import models
        from models.driver_attendance import DriverAttendance, AttendanceRecord
        
        # Get the driver from the database
        driver_record = DriverAttendance.query.get(driver_id)
        
        if not driver_record:
            flash('Driver not found', 'danger')
            return redirect(url_for('driver_module.driver_list'))
        
        # Convert to the format used in templates
        driver = {
            'id': str(driver_record.id),
            'name': driver_record.full_name,
            'employee_id': driver_record.employee_id,
            'status': 'Active' if driver_record.is_active else 'Inactive',
            'region': driver_record.division or 'Unknown',
            'job_site': 'Multiple', # Will be calculated below
            'attendance_score': 0,   # Will be calculated below
            'late_count': 0,         # Will be calculated below
            'early_end_count': 0,    # Will be calculated below
            'not_on_job_count': 0,   # Will be calculated below
            'vehicle': 'N/A'         # Will be updated if available
        }
        
        # Get attendance history from database
        today = datetime.now().date()
        thirty_days_ago = today - timedelta(days=30)
        
        # Query attendance records from the database
        attendance_records = AttendanceRecord.query.filter(
            AttendanceRecord.driver_id == driver_id,
            AttendanceRecord.date.between(thirty_days_ago, today)
        ).order_by(AttendanceRecord.date.desc()).all()
        
        # Process records into history format
        history = []
        
        # Process each attendance record into the format needed for the template
        for record in attendance_records:
            # Determine status
            status = 'On Time'
            if record.late_start:
                status = 'Late Start'
            elif record.early_end:
                status = 'Early End'
            elif record.not_on_job:
                status = 'Not on Job'
            
            # Format times
            scheduled_start = record.expected_start_time.strftime('%I:%M %p') if record.expected_start_time else 'N/A'
            actual_start = record.actual_start_time.strftime('%I:%M %p') if record.actual_start_time else 'N/A'
            scheduled_end = record.expected_end_time.strftime('%I:%M %p') if record.expected_end_time else 'N/A'
            actual_end = record.actual_end_time.strftime('%I:%M %p') if record.actual_end_time else 'N/A'
            
            # Get job site name
            job_site = 'Unknown'
            if record.assigned_job:
                job_site = record.assigned_job.name
            
            # Calculate late/early minutes if applicable
            minutes_late = 0
            if record.late_start and record.expected_start_time and record.actual_start_time:
                time_diff = record.actual_start_time - record.expected_start_time
                minutes_late = int(time_diff.total_seconds() / 60)
                
            minutes_early = 0
            if record.early_end and record.expected_end_time and record.actual_end_time:
                time_diff = record.expected_end_time - record.actual_end_time
                minutes_early = int(time_diff.total_seconds() / 60)
            
            # Create the history entry
            entry = {
                'date': record.date.strftime('%Y-%m-%d'),
                'weekday': record.date.strftime('%A'),
                'job_site': job_site,
                'status': status,
                'scheduled_start': scheduled_start,
                'actual_start': actual_start,
                'scheduled_end': scheduled_end,
                'actual_end': actual_end,
                'vehicle': record.asset_id or 'N/A',
                'notes': record.notes or ''
            }
            
            # Add late/early minutes if applicable
            if minutes_late > 0:
                entry['minutes_late'] = minutes_late
                
            if minutes_early > 0:
                entry['minutes_early'] = minutes_early
            
            history.append(entry)
        
        # Fill in dates with no records to ensure complete 30-day history
        dates_with_records = {record.date.strftime('%Y-%m-%d') for record in attendance_records}
        
        for i in range(30):
            date = today - timedelta(days=i)
            date_str = date.strftime('%Y-%m-%d')
            
            if date_str not in dates_with_records:
                # Add placeholder for days with no records
                history.append({
                    'date': date_str,
                    'weekday': date.strftime('%A'),
                    'job_site': 'N/A',
                    'status': 'No Data',
                    'scheduled_start': 'N/A',
                    'actual_start': 'N/A',
                    'scheduled_end': 'N/A',
                    'actual_end': 'N/A',
                    'vehicle': 'N/A',
                    'notes': ''
                })
        
        # Sort history by date (newest first)
        history = sorted(history, key=lambda x: x['date'], reverse=True)
        
        # Calculate metrics from actual records
        late_count = sum(1 for r in attendance_records if r.late_start)
        early_end_count = sum(1 for r in attendance_records if r.early_end)
        not_on_job_count = sum(1 for r in attendance_records if r.not_on_job)
        
        total_records = len(attendance_records)
        problem_records = late_count + early_end_count + not_on_job_count
        on_time_count = total_records - problem_records
        
        attendance_score = int((on_time_count / total_records) * 100) if total_records > 0 else 0
        
        # Update driver data with calculated metrics
        driver['late_count'] = late_count
        driver['early_end_count'] = early_end_count
        driver['not_on_job_count'] = not_on_job_count
        driver['attendance_score'] = attendance_score
        
        # Find most frequent job site and vehicle
        if attendance_records:
            # Most frequent job site
            job_sites = {}
            for record in attendance_records:
                if record.assigned_job and record.assigned_job.name:
                    site_name = record.assigned_job.name
                    job_sites[site_name] = job_sites.get(site_name, 0) + 1
            
            if job_sites:
                most_frequent_site = max(job_sites.items(), key=lambda x: x[1])[0]
                driver['job_site'] = most_frequent_site
                
            # Most recent vehicle
            vehicles = [r.asset_id for r in attendance_records if r.asset_id]
            if vehicles:
                driver['vehicle'] = vehicles[0]
        
        return render_template('drivers/driver_detail.html', 
                              driver=driver,
                              attendance_history=history)
                              
    except Exception as e:
        logger.error(f"Error loading driver detail: {str(e)}")
        flash(f"Error loading driver details: {str(e)}", "danger")
        return redirect(url_for('driver_module.driver_list'))

@driver_module_bp.route('/job_site_detail/<site_id>')
@login_required
def job_site_detail(site_id):
    """Job site detail page with attendance metrics"""
    try:
        log_navigation(current_user.id, f'driver_module.job_site_detail.{site_id}')
        
        # Import required models
        from models.driver_attendance import AttendanceRecord, JobSite, DriverAttendance
        
        # Get the job site from the database
        site = JobSite.query.get(site_id)
        
        if not site:
            flash('Job site not found', 'danger')
            return redirect(url_for('driver_module.attendance_dashboard'))
        
        # Format for template
        site_data = {
            'id': str(site.id),
            'name': site.name,
            'location': site.location or 'N/A',
            'status': 'Active' if getattr(site, 'is_active', True) else 'Inactive',
            'on_time_count': 0,
            'late_count': 0,
            'not_on_job_count': 0,
            'attendance_score': 0
        }
        
        # Get attendance records for this job site for the last 30 days
        today = datetime.now().date()
        thirty_days_ago = today - timedelta(days=30)
        
        attendance_records = AttendanceRecord.query.filter(
            AttendanceRecord.job_site_id == site_id,
            AttendanceRecord.date.between(thirty_days_ago, today)
        ).all()
        
        # Calculate site metrics
        total_records = len(attendance_records)
        late_count = sum(1 for r in attendance_records if r.late_start)
        early_end_count = sum(1 for r in attendance_records if r.early_end)
        not_on_job_count = sum(1 for r in attendance_records if r.not_on_job)
        on_time_count = total_records - (late_count + early_end_count + not_on_job_count)
        
        site_data['on_time_count'] = on_time_count
        site_data['late_count'] = late_count
        site_data['not_on_job_count'] = not_on_job_count
        site_data['attendance_score'] = int((on_time_count / total_records) * 100) if total_records > 0 else 0
        
        # Get drivers assigned to this job site
        driver_ids = set(record.driver_id for record in attendance_records if record.driver_id)
        drivers = []
        
        for driver_id in driver_ids:
            driver_record = DriverAttendance.query.get(driver_id)
            if driver_record:
                # Get driver-specific attendance records for this site
                driver_site_records = [r for r in attendance_records if r.driver_id == driver_id]
                total_driver_records = len(driver_site_records)
                
                if total_driver_records > 0:
                    driver_late_count = sum(1 for r in driver_site_records if r.late_start)
                    driver_early_end_count = sum(1 for r in driver_site_records if r.early_end)
                    driver_not_on_job_count = sum(1 for r in driver_site_records if r.not_on_job)
                    driver_on_time_count = total_driver_records - (driver_late_count + driver_early_end_count + driver_not_on_job_count)
                    attendance_score = int((driver_on_time_count / total_driver_records) * 100)
                    
                    drivers.append({
                        'id': str(driver_record.id),
                        'name': driver_record.full_name,
                        'employee_id': driver_record.employee_id,
                        'status': 'Active' if getattr(driver_record, 'is_active', True) else 'Inactive',
                        'attendance_score': attendance_score,
                        'late_count': driver_late_count,
                        'early_end_count': driver_early_end_count,
                        'not_on_job_count': driver_not_on_job_count
                    })
        
        # Generate daily metrics for the last 14 days
        daily_metrics = []
        
        # Group attendance records by date
        attendance_by_date = {}
        for record in attendance_records:
            date_str = record.date.strftime('%Y-%m-%d')
            if date_str not in attendance_by_date:
                attendance_by_date[date_str] = {
                    'date': date_str,
                    'driver_count': 0,
                    'on_time_count': 0,
                    'late_count': 0,
                    'early_end_count': 0,
                    'not_on_job_count': 0
                }
            
            attendance_by_date[date_str]['driver_count'] += 1
            
            if record.late_start:
                attendance_by_date[date_str]['late_count'] += 1
            elif record.early_end:
                attendance_by_date[date_str]['early_end_count'] += 1
            elif record.not_on_job:
                attendance_by_date[date_str]['not_on_job_count'] += 1
            else:
                attendance_by_date[date_str]['on_time_count'] += 1
        
        # Generate metrics for the last 14 days
        for i in range(14):
            date = today - timedelta(days=i)
            date_str = date.strftime('%Y-%m-%d')
            
            # Use real data if available, otherwise empty metrics
            if date_str in attendance_by_date:
                data = attendance_by_date[date_str]
                driver_count = data['driver_count']
                on_time_count = data['on_time_count']
                late_count = data['late_count']
                on_time_pct = int((on_time_count / driver_count) * 100) if driver_count > 0 else 0
            else:
                driver_count = 0
                on_time_count = 0
                late_count = 0
                on_time_pct = 0
            
            daily_metrics.append({
                'date': date_str,
                'driver_count': driver_count,
                'on_time_count': on_time_count,
                'late_count': late_count,
                'on_time_percentage': on_time_pct
            })
        
        return render_template('drivers/job_site_detail.html',
                             site=site_data,
                             drivers=drivers,
                             daily_metrics=daily_metrics)
                             
    except Exception as e:
        logger.error(f"Error loading job site detail: {str(e)}")
        flash(f"Error loading job site details: {str(e)}", "danger")
        return redirect(url_for('driver_module.attendance_dashboard'))

@driver_module_bp.route('/region_detail/<region_id>')
@login_required
def region_detail(region_id):
    """Region detail page with attendance metrics"""
    try:
        log_navigation(current_user.id, f'driver_module.region_detail.{region_id}')
        
        # Import required models
        from models.driver_attendance import DriverAttendance, AttendanceRecord, JobSite, Region
        
        # Get the region from the database
        region_record = Region.query.get(region_id)
        
        if not region_record:
            flash('Region not found', 'danger')
            return redirect(url_for('driver_module.attendance_dashboard'))
        
        # Format for template
        region = {
            'id': str(region_record.id),
            'name': region_record.name,
            'code': region_record.code or '',
            'status': 'Active' if getattr(region_record, 'is_active', True) else 'Inactive',
            'on_time_count': 0,
            'late_count': 0,
            'not_on_job_count': 0,
            'attendance_score': 0
        }
        
        # Get all drivers in this region
        driver_records = DriverAttendance.query.filter(
            DriverAttendance.division == region_id
        ).all()
        
        drivers = []
        driver_ids = []
        
        for driver_record in driver_records:
            drivers.append({
                'id': str(driver_record.id),
                'name': driver_record.full_name,
                'employee_id': driver_record.employee_id,
                'status': 'Active' if getattr(driver_record, 'is_active', True) else 'Inactive',
                'region': region_record.name,
                'attendance_score': 0,  # Will be calculated below
                'late_count': 0,  # Will be calculated below
                'early_end_count': 0,  # Will be calculated below
                'not_on_job_count': 0  # Will be calculated below
            })
            driver_ids.append(driver_record.id)
        
        # Get attendance records for these drivers in the last 180 days (6 months)
        today = datetime.now().date()
        six_months_ago = today - timedelta(days=180)
        
        attendance_records = AttendanceRecord.query.filter(
            AttendanceRecord.driver_id.in_(driver_ids),
            AttendanceRecord.date.between(six_months_ago, today)
        ).all()
        
        # Calculate region metrics
        total_records = len(attendance_records)
        late_count = sum(1 for r in attendance_records if r.late_start)
        early_end_count = sum(1 for r in attendance_records if r.early_end)
        not_on_job_count = sum(1 for r in attendance_records if r.not_on_job)
        on_time_count = total_records - (late_count + early_end_count + not_on_job_count)
        
        region['on_time_count'] = on_time_count
        region['late_count'] = late_count
        region['not_on_job_count'] = not_on_job_count
        region['attendance_score'] = int((on_time_count / total_records) * 100) if total_records > 0 else 0
        
        # Calculate metrics for each driver
        for driver in drivers:
            driver_id = driver['id']
            driver_records = [r for r in attendance_records if str(r.driver_id) == driver_id]
            
            driver_total = len(driver_records)
            if driver_total > 0:
                driver_late_count = sum(1 for r in driver_records if r.late_start)
                driver_early_end_count = sum(1 for r in driver_records if r.early_end)
                driver_not_on_job_count = sum(1 for r in driver_records if r.not_on_job)
                driver_on_time_count = driver_total - (driver_late_count + driver_early_end_count + driver_not_on_job_count)
                
                driver['late_count'] = driver_late_count
                driver['early_end_count'] = driver_early_end_count
                driver['not_on_job_count'] = driver_not_on_job_count
                driver['attendance_score'] = int((driver_on_time_count / driver_total) * 100)
        
        # Get all job sites associated with these drivers
        job_site_ids = set(r.job_site_id for r in attendance_records if r.job_site_id)
        job_site_records = JobSite.query.filter(JobSite.id.in_(job_site_ids)).all()
        
        job_sites = []
        for site in job_site_records:
            site_records = [r for r in attendance_records if r.job_site_id == site.id]
            total_site_records = len(site_records)
            
            if total_site_records > 0:
                site_late_count = sum(1 for r in site_records if r.late_start)
                site_early_end_count = sum(1 for r in site_records if r.early_end)
                site_not_on_job_count = sum(1 for r in site_records if r.not_on_job)
                site_on_time_count = total_site_records - (site_late_count + site_early_end_count + site_not_on_job_count)
                
                job_sites.append({
                    'id': str(site.id),
                    'name': site.name,
                    'location': site.location or 'N/A',
                    'attendance_score': int((site_on_time_count / total_site_records) * 100)
                })
        
        # Generate monthly metrics for the last 6 months
        monthly_metrics = []
        
        # Create a function to get the first day of the month
        def get_first_day_of_month(date):
            return date.replace(day=1)
        
        # Create a function to get the last day of the month
        def get_last_day_of_month(date):
            next_month = date.replace(day=28) + timedelta(days=4)
            return (next_month - timedelta(days=next_month.day)).replace(day=next_month.day - 1)
        
        # Group records by month
        for i in range(6):
            current_month = today.replace(day=1) - timedelta(days=i * 30)
            first_day = get_first_day_of_month(current_month)
            last_day = get_last_day_of_month(current_month)
            month_str = first_day.strftime('%B %Y')
            
            # Filter records for this month
            month_records = [r for r in attendance_records 
                            if first_day <= r.date <= last_day]
            
            driver_count = len(set(r.driver_id for r in month_records))
            total_records = len(month_records)
            
            if total_records > 0:
                on_time_count = sum(1 for r in month_records 
                                   if not (r.late_start or r.early_end or r.not_on_job))
                late_count = sum(1 for r in month_records if r.late_start)
                on_time_pct = int((on_time_count / total_records) * 100)
            else:
                on_time_count = 0
                late_count = 0
                on_time_pct = 0
            
            monthly_metrics.append({
                'month': month_str,
                'driver_count': driver_count,
                'on_time_count': on_time_count,
                'late_count': late_count,
                'on_time_percentage': on_time_pct
            })
        
        return render_template('drivers/region_detail.html',
                              region=region,
                              drivers=drivers,
                              job_sites=job_sites,
                              monthly_metrics=monthly_metrics)
                              
    except Exception as e:
        logger.error(f"Error loading region detail: {str(e)}")
        flash(f"Error loading region details: {str(e)}", "danger")
        return redirect(url_for('driver_module.attendance_dashboard'))

@driver_module_bp.route('/upload_attendance', methods=['GET', 'POST'])
@login_required
def upload_attendance():
    """Upload attendance file for processing"""
    try:
        # Import required models
        from models.driver_attendance import AttendanceImportLog
        
        # Ensure the upload directory exists
        upload_dir = os.path.join(os.getcwd(), 'uploads', 'attendance')
        os.makedirs(upload_dir, exist_ok=True)
        
        if request.method == 'POST':
            if 'file' not in request.files:
                flash('No file part', 'danger')
                return redirect(request.url)
            
            file = request.files['file']
            
            if file.filename == '':
                flash('No selected file', 'danger')
                return redirect(request.url)
            
            # Check file extension
            allowed_extensions = {'csv', 'xlsx', 'xls'}
            file_ext = file.filename.rsplit('.', 1)[1].lower() if '.' in file.filename else ''
            
            if file_ext not in allowed_extensions:
                flash(f'File type not allowed. Please upload {", ".join(allowed_extensions)} files.', 'danger')
                return redirect(request.url)
            
            # Create a timestamped filename to prevent overwrites
            timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
            original_filename = file.filename
            safe_filename = secure_filename(original_filename)
            timestamped_filename = f"{timestamp}_{safe_filename}"
            file_path = os.path.join(upload_dir, timestamped_filename)
            
            # Save the file
            file.save(file_path)
            
            # Get file size
            file_size = os.path.getsize(file_path)
            file_size_kb = file_size / 1024
            
            # Log the upload in the database
            import_log = AttendanceImportLog(
                file_name=original_filename,
                file_type=file_ext,
                imported_by=current_user.id if current_user.is_authenticated else None,
                record_count=0,  # Will be updated after processing
                success=True
            )
            db.session.add(import_log)
            db.session.commit()
            
            # Process the attendance file based on file type
            try:
                # Process the file and import data
                if file_ext in ['xlsx', 'xls']:
                    from utils.attendance_import import process_excel_attendance
                    records_processed = process_excel_attendance(file_path)
                elif file_ext == 'csv':
                    from utils.attendance_import import process_csv_attendance
                    records_processed = process_csv_attendance(file_path)
                else:
                    records_processed = 0
                
                # Update the import log with the count of processed records
                import_log.record_count = records_processed
                db.session.commit()
                
                flash(f'File {original_filename} uploaded and processed successfully. {records_processed} records imported.', 'success')
                logger.info(f'Successfully processed {records_processed} records from {original_filename}')
                
                # Redirect to the daily report page to see the results
                return redirect(url_for('driver_module.daily_report'))
                
            except Exception as e:
                # Log the error and update the import record
                error_msg = str(e)
                logger.error(f"Error processing attendance file: {error_msg}")
                import_log.success = False
                import_log.error_message = error_msg
                db.session.commit()
                
                flash(f'Error processing file: {error_msg}', 'danger')
                return redirect(request.url)
                
        # GET request - display the upload form
        import_history = AttendanceImportLog.query.order_by(
            AttendanceImportLog.import_date.desc()
        ).limit(10).all()
        
        return render_template('drivers/upload_attendance.html', 
                               import_history=import_history)
                               
    except Exception as e:
        logger.error(f"Error in upload_attendance route: {str(e)}")
        flash(f"An unexpected error occurred: {str(e)}", "danger")
        return redirect(url_for('driver_module.index'))

@driver_module_bp.route('/export_report', methods=['GET'])
@login_required
def export_report():
    """Export a driver report using real database data"""
    # Get request parameters
    report_type = request.args.get('type', 'daily')
    export_format = request.args.get('format', 'xlsx')
    date_param = request.args.get('date', datetime.now().strftime('%Y-%m-%d'))
    region_id = request.args.get('region')
    direct_download = request.args.get('direct', 'false') == 'true'
    
    try:
        # Parse the date for filtering records
        try:
            report_date = datetime.strptime(date_param, '%Y-%m-%d').date()
        except ValueError:
            report_date = datetime.now().date()
            
        # Generate a filename with timestamp for uniqueness
        timestamp = datetime.now()
        formatted_date = report_date.strftime('%m_%d_%Y')
        filename_base = f"{report_type}_report_{formatted_date}"
        if region_id:
            filename_base += f"_region_{region_id}"
        
        # Add timestamp to ensure uniqueness
        date_str = timestamp.strftime('%H%M%S')
        filename = f"{filename_base}_{date_str}.{export_format}"
        
        # Create exports directory if it doesn't exist
        if not os.path.exists(EXPORTS_FOLDER):
            os.makedirs(EXPORTS_FOLDER)
        
        # Create the output file path
        file_path = os.path.join(EXPORTS_FOLDER, filename)
        
        # Import database models
        from models.driver_attendance import AttendanceRecord, DriverAttendance, JobSiteAttendance
        
        # Prepare data for the report
        attendance_records = []
        
        # Query the database for attendance records
        if report_type == 'daily':
            try:
                # Query for attendance records on the specified date
                query = db.session.query(
                    AttendanceRecord, DriverAttendance, JobSiteAttendance
                ).join(
                    DriverAttendance, AttendanceRecord.driver_id == DriverAttendance.id
                ).join(
                    JobSiteAttendance, AttendanceRecord.assigned_job_id == JobSiteAttendance.id, isouter=True
                ).filter(
                    AttendanceRecord.date == report_date
                )
                
                # Apply region filter if specified
                if region_id:
                    query = query.filter(DriverAttendance.division == region_id)
                
                # Execute the query
                records = query.all()
                
                # Process records for CSV or Excel export
                for record, driver, job_site in records:
                    status = "On Time"
                    if record.late_start:
                        status = "Late Start"
                    elif record.early_end:
                        status = "Early End"
                    elif record.not_on_job:
                        status = "Not on Job"
                    
                    attendance_records.append({
                        'employee_id': driver.employee_id,
                        'name': driver.full_name,
                        'division': driver.division or 'Unknown',
                        'job_site': job_site.name if job_site else 'Unknown',
                        'status': status,
                        'date': record.date,
                        'expected_start': record.expected_start_time,
                        'actual_start': record.actual_start_time,
                        'expected_end': record.expected_end_time,
                        'actual_end': record.actual_end_time,
                        'notes': record.notes,
                        'vehicle': record.asset_id
                    })
                
                # Create the export file
                if export_format == 'csv':
                    import csv
                    
                    with open(file_path, 'w', newline='') as csvfile:
                        fieldnames = ['employee_id', 'name', 'division', 'job_site', 'status', 
                                     'date', 'expected_start', 'actual_start', 'expected_end', 
                                     'actual_end', 'notes', 'vehicle']
                        
                        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                        writer.writeheader()
                        
                        for record in attendance_records:
                            writer.writerow(record)
                
                elif export_format == 'xlsx':
                    # Import required libraries for Excel export
                    import openpyxl
                    from openpyxl.styles import Font, Alignment, PatternFill
                    
                    # Create a new workbook and select the active sheet
                    wb = openpyxl.Workbook()
                    ws = wb.active
                    ws.title = "Driver Attendance"
                    
                    # Add headers with styling
                    headers = ['Employee ID', 'Name', 'Division', 'Job Site', 'Status', 
                              'Date', 'Expected Start', 'Actual Start', 'Expected End', 
                              'Actual End', 'Notes', 'Vehicle']
                    
                    # Add header row
                    for col, header in enumerate(headers, 1):
                        cell = ws.cell(row=1, column=col, value=header)
                        cell.font = Font(bold=True)
                        cell.fill = PatternFill(start_color="DDDDDD", end_color="DDDDDD", fill_type="solid")
                    
                    # Add data rows
                    for row_idx, record in enumerate(attendance_records, 2):
                        ws.cell(row=row_idx, column=1, value=record['employee_id'])
                        ws.cell(row=row_idx, column=2, value=record['name'])
                        ws.cell(row=row_idx, column=3, value=record['division'])
                        ws.cell(row=row_idx, column=4, value=record['job_site'])
                        ws.cell(row=row_idx, column=5, value=record['status'])
                        ws.cell(row=row_idx, column=6, value=record['date'].strftime('%Y-%m-%d') if record['date'] else '')
                        ws.cell(row=row_idx, column=7, value=record['expected_start'].strftime('%H:%M') if record['expected_start'] else '')
                        ws.cell(row=row_idx, column=8, value=record['actual_start'].strftime('%H:%M') if record['actual_start'] else '')
                        ws.cell(row=row_idx, column=9, value=record['expected_end'].strftime('%H:%M') if record['expected_end'] else '')
                        ws.cell(row=row_idx, column=10, value=record['actual_end'].strftime('%H:%M') if record['actual_end'] else '')
                        ws.cell(row=row_idx, column=11, value=record['notes'])
                        ws.cell(row=row_idx, column=12, value=record['vehicle'])
                        
                        # Color-code status
                        status_cell = ws.cell(row=row_idx, column=5)
                        if record['status'] == 'Late Start':
                            status_cell.fill = PatternFill(start_color="FFCCCC", end_color="FFCCCC", fill_type="solid")
                        elif record['status'] == 'Early End':
                            status_cell.fill = PatternFill(start_color="FFEECC", end_color="FFEECC", fill_type="solid")
                        elif record['status'] == 'Not on Job':
                            status_cell.fill = PatternFill(start_color="FFDDDD", end_color="FFDDDD", fill_type="solid")
                        elif record['status'] == 'On Time':
                            status_cell.fill = PatternFill(start_color="CCFFCC", end_color="CCFFCC", fill_type="solid")
                    
                    # Auto-size columns for better readability
                    for col in range(1, len(headers) + 1):
                        column_letter = openpyxl.utils.get_column_letter(col)
                        ws.column_dimensions[column_letter].width = 15
                    
                    # Save the Excel file
                    wb.save(file_path)
                else:
                    flash(f"Unsupported format: {export_format}", "danger")
                    return redirect(url_for('driver_module.daily_report'))
                
            except Exception as e:
                logger.error(f"Error creating export: {str(e)}", exc_info=True)
                flash(f"Error creating export: {str(e)}", "danger")
                return redirect(url_for('driver_module.daily_report'))
            
        elif report_type == 'summary':
            # Logic for summary report
            try:
                # Define date range (e.g., last 7 days)
                end_date = report_date
                start_date = end_date - timedelta(days=6)  # 7 days total
                
                # Query for summary stats
                summary_query = db.session.query(
                    DriverAttendance,
                    db.func.count(AttendanceRecord.id).label('total_days'),
                    db.func.sum(db.case((AttendanceRecord.late_start == True, 1), else_=0)).label('late_count'),
                    db.func.sum(db.case((AttendanceRecord.early_end == True, 1), else_=0)).label('early_end_count'),
                    db.func.sum(db.case((AttendanceRecord.not_on_job == True, 1), else_=0)).label('not_on_job_count')
                ).join(
                    AttendanceRecord, DriverAttendance.id == AttendanceRecord.driver_id
                ).filter(
                    AttendanceRecord.date.between(start_date, end_date)
                )
                
                # Apply region filter if specified
                if region_id:
                    summary_query = summary_query.filter(DriverAttendance.division == region_id)
                
                # Group by driver
                summary_results = summary_query.group_by(DriverAttendance.id).all()
                
                # Process summary results
                for driver, total_days, late_count, early_end_count, not_on_job_count in summary_results:
                    # Calculate on-time days
                    late_count = late_count or 0
                    early_end_count = early_end_count or 0
                    not_on_job_count = not_on_job_count or 0
                    on_time_count = total_days - (late_count + early_end_count + not_on_job_count)
                    
                    # Calculate attendance score
                    attendance_score = round((on_time_count / total_days) * 100) if total_days > 0 else 0
                    
                    attendance_records.append({
                        'employee_id': driver.employee_id,
                        'name': driver.full_name,
                        'division': driver.division or 'Unknown',
                        'total_days': total_days,
                        'on_time_count': on_time_count,
                        'late_count': late_count,
                        'early_end_count': early_end_count,
                        'not_on_job_count': not_on_job_count,
                        'attendance_score': attendance_score
                    })
                
                # Create the export file
                if export_format == 'csv':
                    import csv
                    
                    with open(file_path, 'w', newline='') as csvfile:
                        fieldnames = ['employee_id', 'name', 'division', 'total_days', 
                                     'on_time_count', 'late_count', 'early_end_count', 
                                     'not_on_job_count', 'attendance_score']
                        
                        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                        writer.writeheader()
                        
                        for record in attendance_records:
                            writer.writerow(record)
                
                elif export_format == 'xlsx':
                    # Import required libraries for Excel export
                    import openpyxl
                    from openpyxl.styles import Font, Alignment, PatternFill
                    
                    # Create a new workbook and select the active sheet
                    wb = openpyxl.Workbook()
                    ws = wb.active
                    ws.title = "Attendance Summary"
                    
                    # Add report title
                    ws.cell(row=1, column=1, value=f"Attendance Summary Report ({start_date.strftime('%m/%d/%Y')} - {end_date.strftime('%m/%d/%Y')})")
                    ws.merge_cells('A1:I1')
                    title_cell = ws.cell(row=1, column=1)
                    title_cell.font = Font(bold=True, size=14)
                    title_cell.alignment = Alignment(horizontal='center')
                    
                    # Add headers with styling
                    headers = ['Employee ID', 'Name', 'Division', 'Total Days', 
                              'On Time', 'Late Start', 'Early End', 'Not on Job', 'Attendance Score']
                    
                    # Add header row
                    for col, header in enumerate(headers, 1):
                        cell = ws.cell(row=3, column=col, value=header)
                        cell.font = Font(bold=True)
                        cell.fill = PatternFill(start_color="DDDDDD", end_color="DDDDDD", fill_type="solid")
                    
                    # Add data rows
                    for row_idx, record in enumerate(attendance_records, 4):
                        ws.cell(row=row_idx, column=1, value=record['employee_id'])
                        ws.cell(row=row_idx, column=2, value=record['name'])
                        ws.cell(row=row_idx, column=3, value=record['division'])
                        ws.cell(row=row_idx, column=4, value=record['total_days'])
                        ws.cell(row=row_idx, column=5, value=record['on_time_count'])
                        ws.cell(row=row_idx, column=6, value=record['late_count'])
                        ws.cell(row=row_idx, column=7, value=record['early_end_count'])
                        ws.cell(row=row_idx, column=8, value=record['not_on_job_count'])
                        
                        # Format attendance score
                        score_cell = ws.cell(row=row_idx, column=9, value=f"{record['attendance_score']}%")
                        
                        # Color-code score
                        score = record['attendance_score']
                        if score >= 95:
                            score_cell.fill = PatternFill(start_color="CCFFCC", end_color="CCFFCC", fill_type="solid")
                        elif score >= 90:
                            score_cell.fill = PatternFill(start_color="FFFFCC", end_color="FFFFCC", fill_type="solid")
                        elif score >= 80:
                            score_cell.fill = PatternFill(start_color="FFEECC", end_color="FFEECC", fill_type="solid")
                        else:
                            score_cell.fill = PatternFill(start_color="FFCCCC", end_color="FFCCCC", fill_type="solid")
                    
                    # Auto-size columns for better readability
                    for col in range(1, len(headers) + 1):
                        column_letter = openpyxl.utils.get_column_letter(col)
                        ws.column_dimensions[column_letter].width = 15
                    
                    # Save the Excel file
                    wb.save(file_path)
                
                else:
                    flash(f"Unsupported format: {export_format}", "danger")
                    return redirect(url_for('driver_module.attendance_dashboard'))
                
            except Exception as e:
                logger.error(f"Error creating summary export: {str(e)}", exc_info=True)
                flash(f"Error creating summary export: {str(e)}", "danger")
                return redirect(url_for('driver_module.attendance_dashboard'))
        
        else:
            flash(f"Unsupported report type: {report_type}", "danger")
            return redirect(url_for('driver_module.index'))
        
        # Log the export
        logger.info(f"Successfully generated {report_type} report in {export_format} format")
        
        # Create download URL
        download_url = url_for('driver_module.download_export', filename=filename)
        
        # Return appropriate response
        if direct_download:
            return send_file(file_path, as_attachment=True, download_name=filename)
        else:
            flash(f"Report generated successfully. <a href='{download_url}'>Download {filename}</a>", "success")
            
            if report_type == 'daily':
                return redirect(url_for('driver_module.daily_report', date=date_param))
            elif report_type == 'summary':
                return redirect(url_for('driver_module.attendance_dashboard'))
            else:
                return redirect(url_for('driver_module.index'))
    
    except Exception as e:
        logger.error(f"Error in export_report: {str(e)}", exc_info=True)
        flash(f"Error generating report: {str(e)}", "danger")
        return redirect(url_for('driver_module.index'))
                        'employee_id': driver.employee_id,
                        'name': driver.full_name,
                        'region': driver.division or 'Unknown',
                        'job_site': job_site.name if job_site else 'Unknown',
                        'scheduled_start': scheduled_start,
                        'actual_start': actual_start,
                        'minutes_late': minutes_late,
                        'vehicle': record.asset_id or 'N/A'
                    })
                elif record.early_end:
                    early_end_count += 1
                    
                    # Calculate minutes early
                    minutes_early = 0
                    if record.expected_end_time and record.actual_end_time:
                        time_diff = record.expected_end_time - record.actual_end_time
                        minutes_early = int(time_diff.total_seconds() / 60)
                    
                    # Format time strings
                    scheduled_end = record.expected_end_time.strftime('%I:%M %p') if record.expected_end_time else 'N/A'
                    actual_end = record.actual_end_time.strftime('%I:%M %p') if record.actual_end_time else 'N/A'
                    
                    # Add to early end drivers list
                    early_end_drivers.append({
                        'employee_id': driver.employee_id,
                        'name': driver.full_name,
                        'region': driver.division or 'Unknown',
                        'job_site': job_site.name if job_site else 'Unknown',
                        'scheduled_end': scheduled_end,
                        'actual_end': actual_end,
                        'minutes_early': minutes_early,
                        'vehicle': record.asset_id or 'N/A'
                    })
                elif record.not_on_job:
                    not_on_job_count += 1
                    
                    # Format time strings
                    scheduled_start = record.expected_start_time.strftime('%I:%M %p') if record.expected_start_time else 'N/A'
                    
                    # Add to not on job drivers list
                    not_on_job_drivers.append({
                        'employee_id': driver.employee_id,
                        'name': driver.full_name,
                        'region': driver.division or 'Unknown',
                        'job_site': job_site.name if job_site else 'Unknown',
                        'scheduled_start': scheduled_start,
                        'reason': record.notes or 'Unknown',
                        'vehicle': record.asset_id or 'N/A'
                    })
                else:
                    on_time_count += 1
            
            # Generate the export file based on format
            if export_format == 'csv':
                import csv
                with open(file_path, 'w', newline='') as csvfile:
                    writer = csv.writer(csvfile)
                    # Write header
                    writer.writerow(['TRAXORA FLEET MANAGEMENT'])
                    writer.writerow(['Daily Driver Report', f'Date: {report_date.strftime("%m/%d/%Y")}'])
                    writer.writerow(['Generated:', timestamp.strftime('%m/%d/%Y %I:%M:%S %p')])
                    writer.writerow([])
                    
                    # Summary data
                    writer.writerow(['Summary', ''])
                    writer.writerow(['Total Drivers', total_drivers])
                    writer.writerow(['On Time', on_time_count])
                    writer.writerow(['Late Start', late_start_count])
                    writer.writerow(['Early End', early_end_count])
                    writer.writerow(['Not on Job', not_on_job_count])
                    writer.writerow([])
                    
                    # Late drivers
                    writer.writerow(['Late Drivers', ''])
                    writer.writerow(['Employee ID', 'Driver Name', 'Region', 'Job Site', 'Scheduled Start', 'Actual Start', 'Minutes Late', 'Vehicle'])
                    for driver in late_drivers:
                        writer.writerow([
                            driver['employee_id'],
                            driver['name'],
                            driver['region'],
                            driver['job_site'],
                            driver['scheduled_start'],
                            driver['actual_start'],
                            driver['minutes_late'],
                            driver['vehicle']
                        ])
                    writer.writerow([])
                    
                    # Early end drivers
                    writer.writerow(['Early End Drivers', ''])
                    writer.writerow(['Employee ID', 'Driver Name', 'Region', 'Job Site', 'Scheduled End', 'Actual End', 'Minutes Early', 'Vehicle'])
                    for driver in early_end_drivers:
                        writer.writerow([
                            driver['employee_id'],
                            driver['name'],
                            driver['region'],
                            driver['job_site'],
                            driver['scheduled_end'],
                            driver['actual_end'],
                            driver['minutes_early'],
                            driver['vehicle']
                        ])
                    writer.writerow([])
                    
                    # Not on job drivers
                    writer.writerow(['Not On Job Drivers', ''])
                    writer.writerow(['Employee ID', 'Driver Name', 'Region', 'Job Site', 'Scheduled Start', 'Status', 'Reason', 'Vehicle'])
                    for driver in not_on_job_drivers:
                        writer.writerow([
                            driver['employee_id'],
                            driver['name'],
                            driver['region'],
                            driver['job_site'],
                            driver['scheduled_start'],
                            'Not on Job',
                            driver['reason'],
                            driver['vehicle']
                        ])
            elif export_format == 'xlsx':
                import openpyxl
                from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
                
                wb = openpyxl.Workbook()
                ws = wb.active
                ws.title = "Driver Daily Report"
                
                # Define styles
                header_font = Font(bold=True, size=14)
                subheader_font = Font(bold=True, size=12)
                bold_font = Font(bold=True)
                center_align = Alignment(horizontal='center')
                header_fill = PatternFill(start_color="007BFF", end_color="007BFF", fill_type="solid")
                header_text_color = Font(bold=True, color="FFFFFF")
                
                # Add report header
                ws['A1'] = "TRAXORA FLEET MANAGEMENT"
                ws.merge_cells('A1:H1')
                ws['A1'].font = header_font
                ws['A1'].alignment = center_align
                
                ws['A2'] = f"Daily Driver Report - {report_date.strftime('%m/%d/%Y')}"
                ws.merge_cells('A2:H2')
                ws['A2'].font = subheader_font
                ws['A2'].alignment = center_align
                
                ws['A3'] = f"Generated: {timestamp.strftime('%m/%d/%Y %I:%M:%S %p')}"
                ws.merge_cells('A3:H3')
                ws['A3'].alignment = center_align
                
                # Summary section
                row = 5
                ws[f'A{row}'] = "Summary"
                ws[f'A{row}'].font = bold_font
                
                row += 1
                ws[f'A{row}'] = "Total Drivers"
                ws[f'B{row}'] = total_drivers
                
                row += 1
                ws[f'A{row}'] = "On Time"
                ws[f'B{row}'] = on_time_count
                
                row += 1
                ws[f'A{row}'] = "Late Start"
                ws[f'B{row}'] = late_start_count
                
                row += 1
                ws[f'A{row}'] = "Early End"
                ws[f'B{row}'] = early_end_count
                
                row += 1
                ws[f'A{row}'] = "Not on Job"
                ws[f'B{row}'] = not_on_job_count
                
                # Late drivers section
                row += 2
                ws[f'A{row}'] = "Late Drivers"
                ws[f'A{row}'].font = bold_font
                row += 1
                
                # Add table headers with styling
                headers = ['Employee ID', 'Driver Name', 'Region', 'Job Site', 'Scheduled Start', 'Actual Start', 'Minutes Late', 'Vehicle']
                for col, header in enumerate(headers, 1):
                    cell = ws.cell(row=row, column=col, value=header)
                    cell.font = header_text_color
                    cell.fill = header_fill
                    cell.alignment = center_align
                
                # Add data rows
                row += 1
                for driver in late_drivers:
                    ws.cell(row=row, column=1, value=driver['employee_id'])
                    ws.cell(row=row, column=2, value=driver['name'])
                    ws.cell(row=row, column=3, value=driver['region'])
                    ws.cell(row=row, column=4, value=driver['job_site'])
                    ws.cell(row=row, column=5, value=driver['scheduled_start'])
                    ws.cell(row=row, column=6, value=driver['actual_start'])
                    ws.cell(row=row, column=7, value=driver['minutes_late'])
                    ws.cell(row=row, column=8, value=driver['vehicle'])
                    row += 1
                
                # Early end drivers section
                row += 2
                ws[f'A{row}'] = "Early End Drivers"
                ws[f'A{row}'].font = bold_font
                row += 1
                
                headers = ['Employee ID', 'Driver Name', 'Region', 'Job Site', 'Scheduled End', 'Actual End', 'Minutes Early', 'Vehicle']
                for col, header in enumerate(headers, 1):
                    cell = ws.cell(row=row, column=col, value=header)
                    cell.font = header_text_color
                    cell.fill = header_fill
                    cell.alignment = center_align
                
                row += 1
                for driver in early_end_drivers:
                    ws.cell(row=row, column=1, value=driver['employee_id'])
                    ws.cell(row=row, column=2, value=driver['name'])
                    ws.cell(row=row, column=3, value=driver['region'])
                    ws.cell(row=row, column=4, value=driver['job_site'])
                    ws.cell(row=row, column=5, value=driver['scheduled_end'])
                    ws.cell(row=row, column=6, value=driver['actual_end'])
                    ws.cell(row=row, column=7, value=driver['minutes_early'])
                    ws.cell(row=row, column=8, value=driver['vehicle'])
                    row += 1
                
                # Not on job drivers section
                row += 2
                ws[f'A{row}'] = "Not On Job Drivers"
                ws[f'A{row}'].font = bold_font
                row += 1
                
                headers = ['Employee ID', 'Driver Name', 'Region', 'Job Site', 'Scheduled Start', 'Status', 'Reason', 'Vehicle']
                for col, header in enumerate(headers, 1):
                    cell = ws.cell(row=row, column=col, value=header)
                    cell.font = header_text_color
                    cell.fill = header_fill
                    cell.alignment = center_align
                
                row += 1
                for driver in not_on_job_drivers:
                    ws.cell(row=row, column=1, value=driver['employee_id'])
                    ws.cell(row=row, column=2, value=driver['name'])
                    ws.cell(row=row, column=3, value=driver['region'])
                    ws.cell(row=row, column=4, value=driver['job_site'])
                    ws.cell(row=row, column=5, value=driver['scheduled_start'])
                    ws.cell(row=row, column=6, value='Not on Job')
                    ws.cell(row=row, column=7, value=driver['reason'])
                    ws.cell(row=row, column=8, value=driver['vehicle'])
                    row += 1
                
                # Auto-size columns
                for column in ws.columns:
                    max_length = 0
                    column_letter = column[0].column_letter
                    for cell in column:
                        if cell.value:
                            max_length = max(max_length, len(str(cell.value)))
                    adjusted_width = (max_length + 2) * 1.2
                    ws.column_dimensions[column_letter].width = adjusted_width
                
                # Save the Excel file
                wb.save(file_path)
            else:
                flash(f'Unsupported export format: {export_format}', 'danger')
                return redirect(url_for('driver_module.daily_report'))
            
        elif report_type == 'summary':
            # Define date range for summary report (last 7 days by default)
            end_date = report_date
            start_date = end_date - timedelta(days=6)  # 7 days including end date
            
            # Query for attendance summary by driver
            summary_query = db.session.query(
                DriverAttendance,
                db.func.count(AttendanceRecord.id).label('total_records'),
                db.func.sum(db.case((AttendanceRecord.late_start == True, 1), else_=0)).label('late_count'),
                db.func.sum(db.case((AttendanceRecord.early_end == True, 1), else_=0)).label('early_end_count'),
                db.func.sum(db.case((AttendanceRecord.not_on_job == True, 1), else_=0)).label('not_on_job_count')
            ).join(
                AttendanceRecord, DriverAttendance.id == AttendanceRecord.driver_id
            ).filter(
                AttendanceRecord.date.between(start_date, end_date)
            )
            
            # Apply region filter if specified
            if region_id:
                summary_query = summary_query.filter(DriverAttendance.division == region_id)
            
            # Group and order by driver
            summary_results = summary_query.group_by(DriverAttendance.id).order_by(DriverAttendance.last_name).all()
            
            # Process the summary results
            summary_data = []
            for driver, total, late_count, early_end_count, not_on_job_count in summary_results:
                # Calculate on-time count and attendance score
                late_count = late_count or 0
                early_end_count = early_end_count or 0
                not_on_job_count = not_on_job_count or 0
                problem_count = late_count + early_end_count + not_on_job_count
                on_time_count = total - problem_count
                attendance_score = int((on_time_count / total) * 100) if total > 0 else 0
                
                summary_data.append({
                    'employee_id': driver.employee_id,
                    'name': driver.full_name,
                    'division': driver.division or 'Unknown',
                    'total_days': total,
                    'on_time_count': on_time_count,
                    'late_count': late_count,
                    'early_end_count': early_end_count,
                    'not_on_job_count': not_on_job_count,
                    'attendance_score': attendance_score
                })
            
            # Generate the export file based on format
            if export_format == 'csv':
                import csv
                with open(file_path, 'w', newline='') as csvfile:
                    writer = csv.writer(csvfile)
                    # Write header
                    writer.writerow(['TRAXORA FLEET MANAGEMENT'])
                    writer.writerow(['Driver Attendance Summary', f'Date Range: {start_date.strftime("%m/%d/%Y")} to {end_date.strftime("%m/%d/%Y")}'])
                    writer.writerow(['Generated:', timestamp.strftime('%m/%d/%Y %I:%M:%S %p')])
                    writer.writerow([])
                    
                    # Write column headers
                    writer.writerow([
                        'Employee ID', 'Driver Name', 'Division', 'Total Days',
                        'On Time', 'Late Start', 'Early End', 'Not on Job', 'Attendance Score'
                    ])
                    
                    # Write data rows
                    for data in summary_data:
                        writer.writerow([
                            data['employee_id'],
                            data['name'],
                            data['division'],
                            data['total_days'],
                            data['on_time_count'],
                            data['late_count'],
                            data['early_end_count'],
                            data['not_on_job_count'],
                            f"{data['attendance_score']}%"
                        ])
            elif export_format == 'xlsx':
                import openpyxl
                from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
                
                wb = openpyxl.Workbook()
                ws = wb.active
                ws.title = "Attendance Summary"
                
                # Define styles
                header_font = Font(bold=True, size=14)
                subheader_font = Font(bold=True, size=12)
                bold_font = Font(bold=True)
                center_align = Alignment(horizontal='center')
                header_fill = PatternFill(start_color="007BFF", end_color="007BFF", fill_type="solid")
                header_text_color = Font(bold=True, color="FFFFFF")
                
                # Add report header
                ws['A1'] = "TRAXORA FLEET MANAGEMENT"
                ws.merge_cells('A1:I1')
                ws['A1'].font = header_font
                ws['A1'].alignment = center_align
                
                ws['A2'] = f"Driver Attendance Summary - {start_date.strftime('%m/%d/%Y')} to {end_date.strftime('%m/%d/%Y')}"
                ws.merge_cells('A2:I2')
                ws['A2'].font = subheader_font
                ws['A2'].alignment = center_align
                
                row = 4
                
                # Add table headers with styling
                headers = [
                    'Employee ID', 'Driver Name', 'Division', 'Total Days',
                    'On Time', 'Late Start', 'Early End', 'Not on Job', 'Attendance Score'
                ]
                
                for col, header in enumerate(headers, 1):
                    cell = ws.cell(row=row, column=col, value=header)
                    cell.font = header_text_color
                    cell.fill = header_fill
                    cell.alignment = center_align
                
                # Add data rows
                row += 1
                for data in summary_data:
                    # Add regular cells
                    ws.cell(row=row, column=1, value=data['employee_id'])
                    ws.cell(row=row, column=2, value=data['name'])
                    ws.cell(row=row, column=3, value=data['division'])
                    ws.cell(row=row, column=4, value=data['total_days'])
                    ws.cell(row=row, column=5, value=data['on_time_count'])
                    ws.cell(row=row, column=6, value=data['late_count'])
                    ws.cell(row=row, column=7, value=data['early_end_count'])
                    ws.cell(row=row, column=8, value=data['not_on_job_count'])
                    
                    # Add score with color coding
                    score_cell = ws.cell(row=row, column=9, value=f"{data['attendance_score']}%")
                    score_cell.alignment = center_align
                    
                    # Color coding based on score
                    score = data['attendance_score']
                    if score >= 95:
                        score_cell.fill = PatternFill(start_color="CCFFCC", end_color="CCFFCC", fill_type="solid")
                    elif score >= 90:
                        score_cell.fill = PatternFill(start_color="FFFFCC", end_color="FFFFCC", fill_type="solid")
                    elif score >= 80:
                        score_cell.fill = PatternFill(start_color="FFDDCC", end_color="FFDDCC", fill_type="solid")
                    else:
                        score_cell.fill = PatternFill(start_color="FFCCCC", end_color="FFCCCC", fill_type="solid")
                    
                    row += 1
                
                # Auto-size columns
                for column in ws.columns:
                    max_length = 0
                    column_letter = column[0].column_letter
                    for cell in column:
                        if cell.value:
                            max_length = max(max_length, len(str(cell.value)))
                    adjusted_width = (max_length + 2) * 1.2
                    ws.column_dimensions[column_letter].width = adjusted_width
                
                # Save the Excel file
                wb.save(file_path)
            else:
                flash(f'Unsupported export format: {export_format}', 'danger')
                return redirect(url_for('driver_module.attendance_dashboard'))
        else:
            flash(f'Unsupported report type: {report_type}', 'danger')
            return redirect(url_for('driver_module.index'))
        
        # Log the export to the database
        log_report_export(
            filename=filename,
            report_type=report_type,
            export_format=export_format,
            document_type='driver_report'
        )
        
        # Show success message
        flash(f'Report has been exported successfully as {filename}', 'success')
        
        # Return appropriate response based on direct_download flag
        if direct_download:
            return send_file(file_path, as_attachment=True)
        
        # Redirect to appropriate page based on report type
        if report_type == 'daily':
            return redirect(url_for('driver_module.daily_report', date=date_param))
        elif report_type == 'summary':
            return redirect(url_for('driver_module.attendance_dashboard'))
        else:
            return redirect(url_for('driver_module.index'))
    
    except Exception as e:
        # Log the error
        logger.error(f"Error generating report: {str(e)}", exc_info=True)
        flash(f"Error generating report: {str(e)}", "danger")
        return redirect(url_for('driver_module.index'))
        
        # Generate base filename
        formatted_date = report_date.strftime('%m_%d_%Y')
        filename_base = f"{report_type}_report_{formatted_date}"
        if region_id:
            filename_base += f"_region_{region_id}"
        
        # Add timestamp to ensure uniqueness
        date_str = timestamp.strftime('%H%M%S')
        filename = f"{filename_base}_{date_str}.{export_format}"
        
        # Create the output file based on requested format
        file_path = os.path.join(EXPORTS_FOLDER, filename)
        
        # Get real data from the database
        # Import database models
        from models.driver_attendance import AttendanceRecord, DriverAttendance, JobSiteAttendance
        
        # Initialize report_data
        report_data = {}
        
        # Generate report based on type
        if report_type == 'daily':
            # Query to get all attendance records for the specified date
            query = db.session.query(
                AttendanceRecord, DriverAttendance, JobSiteAttendance
            ).join(
                DriverAttendance, AttendanceRecord.driver_id == DriverAttendance.id
            ).join(
                JobSiteAttendance, AttendanceRecord.assigned_job_id == JobSiteAttendance.id, isouter=True
            ).filter(
                AttendanceRecord.date == report_date
            )
            
            # Add region filter if specified
            if region_id:
                query = query.filter(DriverAttendance.division == region_id)
            
            # Execute the query
            results = query.all()
            
            # Initialize counters and data containers
            total_drivers = len(results)
            on_time_count = 0
            late_start_count = 0
            early_end_count = 0
            not_on_job_count = 0
            
            late_drivers = []
            early_end_drivers = []
            not_on_job_drivers = []
            
            # Process the results
            for record, driver, job_site in results:
                # Determine driver status
                if record.late_start:
                    late_start_count += 1
                    
                    # Calculate late minutes
                    minutes_late = 0
                    if record.expected_start_time and record.actual_start_time:
                        time_diff = record.actual_start_time - record.expected_start_time
                        minutes_late = int(time_diff.total_seconds() / 60)
                    
                    # Format times
                    scheduled_start = record.expected_start_time.strftime('%I:%M %p') if record.expected_start_time else 'N/A'
                    actual_start = record.actual_start_time.strftime('%I:%M %p') if record.actual_start_time else 'N/A'
                    
                    # Add to late drivers list
                    late_drivers.append({
                        'employee_id': driver.employee_id,
                        'name': driver.full_name,
                        'region': driver.division or 'Unknown',
                        'job_site': job_site.name if job_site else 'Unknown',
                        'scheduled_start': scheduled_start,
                        'actual_start': actual_start,
                        'minutes_late': minutes_late,
                        'vehicle': record.asset_id or 'N/A'
                    })
                    
                elif record.early_end:
                    early_end_count += 1
                    
                    # Calculate early minutes
                    minutes_early = 0
                    if record.expected_end_time and record.actual_end_time:
                        time_diff = record.expected_end_time - record.actual_end_time
                        minutes_early = int(time_diff.total_seconds() / 60)
                    
                    # Format times
                    scheduled_end = record.expected_end_time.strftime('%I:%M %p') if record.expected_end_time else 'N/A'
                    actual_end = record.actual_end_time.strftime('%I:%M %p') if record.actual_end_time else 'N/A'
                    
                    # Add to early end drivers list
                    early_end_drivers.append({
                        'employee_id': driver.employee_id,
                        'name': driver.full_name,
                        'region': driver.division or 'Unknown',
                        'job_site': job_site.name if job_site else 'Unknown',
                        'scheduled_end': scheduled_end,
                        'actual_end': actual_end,
                        'minutes_early': minutes_early,
                        'vehicle': record.asset_id or 'N/A'
                    })
                    
                elif record.not_on_job:
                    not_on_job_count += 1
                    
                    # Format times
                    scheduled_start = record.expected_start_time.strftime('%I:%M %p') if record.expected_start_time else 'N/A'
                    
                    # Add to not on job drivers list
                    not_on_job_drivers.append({
                        'employee_id': driver.employee_id,
                        'name': driver.full_name,
                        'region': driver.division or 'Unknown',
                        'job_site': job_site.name if job_site else 'Unknown',
                        'scheduled_start': scheduled_start,
                        'reason': record.notes or 'Unknown',
                        'vehicle': record.asset_id or 'N/A'
                    })
                    
                else:
                    on_time_count += 1
            
            # Prepare the report data
            report_data = {
                'total_drivers': total_drivers,
                'on_time': on_time_count,
                'late_start': late_start_count,
                'early_end': early_end_count,
                'not_on_job': not_on_job_count,
                'late_drivers': late_drivers,
                'early_end_drivers': early_end_drivers,
                'not_on_job_drivers': not_on_job_drivers
            }
            
        elif report_type == 'summary':
            # Generate summary report data with attendance trends
            # Determine date range (last 7 days by default)
            end_date = report_date
            start_date = end_date - timedelta(days=6)  # 7 days total including end_date
            
            # Query for attendance summary by driver
            driver_summary = db.session.query(
                DriverAttendance,
                db.func.count(AttendanceRecord.id).label('total_records'),
                db.func.sum(db.case((AttendanceRecord.late_start == True, 1), else_=0)).label('late_count'),
                db.func.sum(db.case((AttendanceRecord.early_end == True, 1), else_=0)).label('early_end_count'),
                db.func.sum(db.case((AttendanceRecord.not_on_job == True, 1), else_=0)).label('not_on_job_count')
            ).join(
                AttendanceRecord, DriverAttendance.id == AttendanceRecord.driver_id
            ).filter(
                AttendanceRecord.date.between(start_date, end_date)
            )
            
            # Add region filter if specified
            if region_id:
                driver_summary = driver_summary.filter(DriverAttendance.division == region_id)
            
            # Group and order by driver
            driver_summary = driver_summary.group_by(DriverAttendance.id).order_by(DriverAttendance.last_name).all()
            
            # Format the data for export
            summary_data = []
            
            for driver, total, late_count, early_end_count, not_on_job_count in driver_summary:
                # Calculate on-time count and attendance score
                problem_count = (late_count or 0) + (early_end_count or 0) + (not_on_job_count or 0)
                on_time_count = total - problem_count
                attendance_score = int((on_time_count / total) * 100) if total > 0 else 0
                
                summary_data.append({
                    'employee_id': driver.employee_id,
                    'name': driver.full_name,
                    'division': driver.division or 'Unknown',
                    'total_days': total,
                    'on_time_count': on_time_count,
                    'late_count': late_count or 0,
                    'early_end_count': early_end_count or 0,
                    'not_on_job_count': not_on_job_count or 0,
                    'attendance_score': attendance_score
                })
            
            # Prepare the report data
            report_data = {
                'summary_data': summary_data,
                'start_date': start_date,
                'end_date': end_date
            }
        
        # Generate the appropriate report format
        if export_format == 'csv':
            # Generate CSV file with proper formatting
            import csv
            with open(file_path, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile)
                # Write header
                writer.writerow(['Driver Report', f'Date: {report_date.strftime("%m/%d/%Y")}'])
                writer.writerow(['Generated:', timestamp.strftime('%m/%d/%Y %I:%M:%S %p')])
                writer.writerow([])
                
                # Summary data
            writer.writerow(['Summary', ''])
            writer.writerow(['Total Drivers', report_data['total_drivers']])
            writer.writerow(['On Time', report_data['on_time']])
            writer.writerow(['Late Start', report_data['late_start']])
            writer.writerow(['Early End', report_data['early_end']])
            writer.writerow(['Not on Job', report_data['not_on_job']])
            writer.writerow([])
            
            # Late drivers
            writer.writerow(['Late Drivers', ''])
            writer.writerow(['Employee ID', 'Driver Name', 'Region', 'Job Site', 'Scheduled Start', 'Actual Start', 'Minutes Late', 'Vehicle'])
            for driver in report_data['late_drivers']:
                writer.writerow([
                    driver['employee_id'],
                    driver['name'],
                    driver['region'],
                    driver['job_site'],
                    driver['scheduled_start'],
                    driver['actual_start'],
                    driver['minutes_late'],
                    driver['vehicle']
                ])
            writer.writerow([])
            
            # Early end drivers
            writer.writerow(['Early End Drivers', ''])
            writer.writerow(['Employee ID', 'Driver Name', 'Region', 'Job Site', 'Scheduled End', 'Actual End', 'Minutes Early', 'Vehicle'])
            for driver in report_data['early_end_drivers']:
                writer.writerow([
                    driver['employee_id'],
                    driver['name'],
                    driver['region'],
                    driver['job_site'],
                    driver['scheduled_end'],
                    driver['actual_end'],
                    driver['minutes_early'],
                    driver['vehicle']
                ])
            
    elif export_format == 'xlsx':
        # Generate Excel file with formatting
        try:
            import pandas as pd
            from openpyxl import Workbook
            from openpyxl.styles import Font, Alignment, PatternFill
            
            # Create workbook and sheet
            wb = Workbook()
            ws = wb.active
            ws.title = "Driver Report"
            
            # Add header with formatting
            ws['A1'] = f"Driver Daily Report - {timestamp.strftime('%m/%d/%Y')}"
            ws['A1'].font = Font(bold=True, size=14)
            ws.merge_cells('A1:H1')
            
            ws['A2'] = f"Generated: {timestamp.strftime('%m/%d/%Y %I:%M:%S %p')}"
            ws.merge_cells('A2:H2')
            
            # Summary section
            ws['A4'] = "Summary"
            ws['A4'].font = Font(bold=True)
            
            labels = ["Total Drivers", "On Time", "Late Start", "Early End", "Not on Job"]
            values = [
                report_data['total_drivers'],
                report_data['on_time'],
                report_data['late_start'],
                report_data['early_end'],
                report_data['not_on_job']
            ]
            
            for i, (label, value) in enumerate(zip(labels, values)):
                ws[f'A{i+5}'] = label
                ws[f'B{i+5}'] = value
            
            # Late drivers section
            row = 11
            ws[f'A{row}'] = "Late Drivers"
            ws[f'A{row}'].font = Font(bold=True)
            row += 1
            
            # Header row for late drivers
            headers = ['Employee ID', 'Driver Name', 'Region', 'Job Site', 'Scheduled Start', 'Actual Start', 'Minutes Late', 'Vehicle']
            for col, header in enumerate(headers, start=1):
                ws.cell(row=row, column=col, value=header).font = Font(bold=True)
            row += 1
            
            # Data rows for late drivers
            for driver in report_data['late_drivers']:
                ws.cell(row=row, column=1, value=driver['employee_id'])
                ws.cell(row=row, column=2, value=driver['name'])
                ws.cell(row=row, column=3, value=driver['region'])
                ws.cell(row=row, column=4, value=driver['job_site'])
                ws.cell(row=row, column=5, value=driver['scheduled_start'])
                ws.cell(row=row, column=6, value=driver['actual_start'])
                ws.cell(row=row, column=7, value=driver['minutes_late'])
                ws.cell(row=row, column=8, value=driver['vehicle'])
                row += 1
            
            # Early end drivers section
            row += 2
            ws[f'A{row}'] = "Early End Drivers"
            ws[f'A{row}'].font = Font(bold=True)
            row += 1
            
            # Header row for early end drivers
            headers = ['Employee ID', 'Driver Name', 'Region', 'Job Site', 'Scheduled End', 'Actual End', 'Minutes Early', 'Vehicle']
            for col, header in enumerate(headers, start=1):
                ws.cell(row=row, column=col, value=header).font = Font(bold=True)
            row += 1
            
            # Data rows for early end drivers
            for driver in report_data['early_end_drivers']:
                ws.cell(row=row, column=1, value=driver['employee_id'])
                ws.cell(row=row, column=2, value=driver['name'])
                ws.cell(row=row, column=3, value=driver['region'])
                ws.cell(row=row, column=4, value=driver['job_site'])
                ws.cell(row=row, column=5, value=driver['scheduled_end'])
                ws.cell(row=row, column=6, value=driver['actual_end'])
                ws.cell(row=row, column=7, value=driver['minutes_early'])
                ws.cell(row=row, column=8, value=driver['vehicle'])
                row += 1
            
            # Auto-adjust column widths
            for col in ws.columns:
                max_length = 0
                column = col[0].column_letter
                for cell in col:
                    if cell.value:
                        max_length = max(max_length, len(str(cell.value)))
                adjusted_width = (max_length + 2)
                ws.column_dimensions[column].width = adjusted_width
            
            # Save the workbook
            wb.save(file_path)
            
        except Exception as e:
            logging.error(f"Error generating Excel file: {e}")
            # Fallback to simpler file if Excel generation fails
            with open(file_path, 'w') as f:
                f.write(f"Driver Report - {timestamp.strftime('%m/%d/%Y')}\n")
                f.write(f"Generated: {timestamp.strftime('%m/%d/%Y %I:%M:%S %p')}\n\n")
                f.write(f"Total Drivers: {report_data['total_drivers']}\n")
                f.write(f"On Time: {report_data['on_time']}\n")
                f.write(f"Late Start: {report_data['late_start']}\n")
                f.write(f"Early End: {report_data['early_end']}\n")
                f.write(f"Not on Job: {report_data['not_on_job']}\n")
            
    else:  # Default to PDF or text
        # Generate a simple PDF using reportlab if PDF requested
        if export_format == 'pdf':
            try:
                from reportlab.lib.pagesizes import letter
                from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
                from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
                from reportlab.lib import colors
                
                # Create document
                doc = SimpleDocTemplate(file_path, pagesize=letter)
                styles = getSampleStyleSheet()
                elements = []
                
                # Add title
                title_style = styles['Heading1']
                elements.append(Paragraph(f"Driver Daily Report - {timestamp.strftime('%m/%d/%Y')}", title_style))
                elements.append(Spacer(1, 12))
                elements.append(Paragraph(f"Generated: {timestamp.strftime('%m/%d/%Y %I:%M:%S %p')}", styles['Normal']))
                elements.append(Spacer(1, 24))
                
                # Summary section
                elements.append(Paragraph("Summary", styles['Heading2']))
                
                summary_data = [
                    ["Total Drivers", str(report_data['total_drivers'])],
                    ["On Time", str(report_data['on_time'])],
                    ["Late Start", str(report_data['late_start'])],
                    ["Early End", str(report_data['early_end'])],
                    ["Not on Job", str(report_data['not_on_job'])]
                ]
                
                summary_table = Table(summary_data, colWidths=[200, 100])
                summary_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
                    ('TEXTCOLOR', (0, 0), (0, -1), colors.black),
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                    ('FONTSIZE', (0, 0), (-1, -1), 10),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black)
                ]))
                elements.append(summary_table)
                elements.append(Spacer(1, 24))
                
                # Late drivers section
                elements.append(Paragraph("Late Drivers", styles['Heading2']))
                
                if report_data['late_drivers']:
                    # Create table header
                    late_data = [['Employee ID', 'Driver Name', 'Region', 'Job Site', 'Scheduled', 'Actual', 'Minutes Late']]
                    
                    # Add data rows
                    for driver in report_data['late_drivers']:
                        late_data.append([
                            driver['employee_id'],
                            driver['name'],
                            driver['region'],
                            driver['job_site'],
                            driver['scheduled_start'],
                            driver['actual_start'],
                            str(driver['minutes_late'])
                        ])
                    
                    late_table = Table(late_data, colWidths=[80, 100, 60, 100, 70, 70, 60])
                    late_table.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, 0), (-1, 0), 10),
                        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                        ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
                        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                        ('FONTSIZE', (0, 1), (-1, -1), 9),
                        ('BOTTOMPADDING', (0, 1), (-1, -1), 6),
                        ('GRID', (0, 0), (-1, -1), 1, colors.black)
                    ]))
                    elements.append(late_table)
                else:
                    elements.append(Paragraph("No late drivers reported today", styles['Normal']))
                
                elements.append(Spacer(1, 24))
                
                # Early end drivers section
                elements.append(Paragraph("Early End Drivers", styles['Heading2']))
                
                if report_data['early_end_drivers']:
                    # Create table header
                    early_data = [['Employee ID', 'Driver Name', 'Region', 'Job Site', 'Scheduled', 'Actual', 'Minutes Early']]
                    
                    # Add data rows
                    for driver in report_data['early_end_drivers']:
                        early_data.append([
                            driver['employee_id'],
                            driver['name'],
                            driver['region'],
                            driver['job_site'],
                            driver['scheduled_end'],
                            driver['actual_end'],
                            str(driver['minutes_early'])
                        ])
                    
                    early_table = Table(early_data, colWidths=[80, 100, 60, 100, 70, 70, 60])
                    early_table.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, 0), (-1, 0), 10),
                        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                        ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
                        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                        ('FONTSIZE', (0, 1), (-1, -1), 9),
                        ('BOTTOMPADDING', (0, 1), (-1, -1), 6),
                        ('GRID', (0, 0), (-1, -1), 1, colors.black)
                    ]))
                    elements.append(early_table)
                else:
                    elements.append(Paragraph("No early end drivers reported today", styles['Normal']))
                
                # Build the PDF
                doc.build(elements)
                
            except Exception as e:
                logging.error(f"Error generating PDF: {e}")
                # Create a text file as fallback
                with open(file_path, 'w') as f:
                    f.write(f"Driver Report - {timestamp.strftime('%m/%d/%Y')}\n")
                    f.write(f"Generated: {timestamp.strftime('%m/%d/%Y %I:%M:%S %p')}\n\n")
                    f.write(f"Total Drivers: {report_data['total_drivers']}\n")
                    f.write(f"On Time: {report_data['on_time']}\n")
                    f.write(f"Late Start: {report_data['late_start']}\n")
                    f.write(f"Early End: {report_data['early_end']}\n")
                    f.write(f"Not on Job: {report_data['not_on_job']}\n")
        else:
            # Create a text file
            with open(file_path, 'w') as f:
                f.write(f"Driver Report - {timestamp.strftime('%m/%d/%Y')}\n")
                f.write(f"Generated: {timestamp.strftime('%m/%d/%Y %I:%M:%S %p')}\n\n")
                f.write(f"Total Drivers: {report_data['total_drivers']}\n")
                f.write(f"On Time: {report_data['on_time']}\n")
                f.write(f"Late Start: {report_data['late_start']}\n")
                f.write(f"Early End: {report_data['early_end']}\n")
                f.write(f"Not on Job: {report_data['not_on_job']}\n")
    
    # Log the export
    log_report_export(
        report_type=report_type,
        export_format=export_format
    )
    
    # If direct download requested, send the file directly
    if direct_download:
        return send_file(file_path, as_attachment=True)
    
    # Otherwise, show a confirmation page with navigation options
    return render_template(
        'drivers/export_success.html',
        filename=filename,
        report_type=report_type,
        export_format=export_format,
        download_url=url_for('driver_module.download_export', filename=filename),
        now=datetime.now()
    )

@driver_module_bp.route('/download_export/<filename>')
@login_required
def download_export(filename):
    """Download a previously exported file"""
    file_path = os.path.join(EXPORTS_FOLDER, filename)
    if os.path.exists(file_path):
        return send_file(file_path, as_attachment=True)
    flash('Export file not found.', 'danger')
    return redirect(url_for('driver_module.daily_report'))

# API endpoints for AJAX requests
@driver_module_bp.route('/api/attendance_chart_data')
@login_required
def attendance_chart_data():
    """Get attendance data for charts"""
    stats = get_sample_attendance_stats()
    
    # Log feature usage
    log_feature_usage('attendance_chart_data')
    
    return jsonify(stats)

@driver_module_bp.route('/api/driver_search')
@login_required
def driver_search():
    """Search for drivers"""
    query = request.args.get('q', '').lower()
    drivers = get_sample_drivers()
    
    if query:
        drivers = [d for d in drivers if 
                   query in d['name'].lower() or 
                   query in d['employee_id'].lower() or
                   query in d['job_site'].lower()]
        
        # Log search
        log_search(query, results_count=len(drivers))
    
    return jsonify({'results': drivers})

@driver_module_bp.route('/api/get_driver/<driver_id>')
@login_required
def get_driver(driver_id):
    """Get driver by ID"""
    drivers = get_sample_drivers()
    driver = next((d for d in drivers if d['id'] == driver_id), None)
    
    if not driver:
        return jsonify({'error': 'Driver not found'}), 404
    
    return jsonify(driver)
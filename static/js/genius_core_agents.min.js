class GeniusAgentSystem { constructor() { this.agents = {}; this.messageQueue = []; this.taskRegistry = {}; this.continuityMode = true; this.masterLog = []; this.registerAgent('AssetTracker', this.createAssetTrackerAgent()); this.registerAgent('JobSiteMonitor', this.createJobSiteMonitorAgent()); this.registerAgent('RecommendationEngine', this.createRecommendationAgent()); this.registerAgent('AnomalyDetector', this.createAnomalyDetectorAgent()); this.registerAgent('BillingVerifier', this.createBillingVerifierAgent()); this.startEventLoop(); console.log('GENIUS CORE Multi-Agent System Initialized'); this.broadcastMessage('SystemAgent', 'system-ready', { timestamp: new Date().toISOString(), status: 'GENIUS CORE CONTINUITY MODE ACTIVE' }); } registerAgent(agentId, agentObject) { this.agents[agentId] = agentObject; console.log(`Agent registered: ${agentId}`); return agentId; } sendMessage(fromAgent, toAgent, messageType, payload) { if (!this.agents[toAgent]) { console.warn(`Unknown agent: ${toAgent}`); return false; } const message = { from: fromAgent, to: toAgent, type: messageType, payload: payload, timestamp: new Date().toISOString(), id: this.generateMessageId() }; this.messageQueue.push(message); return message.id; } broadcastMessage(fromAgent, messageType, payload) { const messageId = this.generateMessageId(); Object.keys(this.agents).forEach(agentId => { if (agentId !== fromAgent) { this.messageQueue.push({ from: fromAgent, to: agentId, type: messageType, payload: payload, timestamp: new Date().toISOString(), id: messageId }); } }); return messageId; } processNextMessage() { if (this.messageQueue.length === 0) return null; const message = this.messageQueue.shift(); const targetAgent = this.agents[message.to]; if (targetAgent && typeof targetAgent.handleMessage === 'function') { try { const response = targetAgent.handleMessage(message); this.logMessage(message, response); return response; } catch (error) { console.error(`Error processing message by agent ${message.to}:`, error); return { error: error.message }; } } return null; } processAllMessages() { while (this.messageQueue.length > 0) { this.processNextMessage(); } } logMessage(message, response) { this.masterLog.push({ message: message, response: response, timestamp: new Date().toISOString() }); if (this.masterLog.length > 1000) { this.masterLog.shift(); } } generateMessageId() { return 'msg_' + Math.random().toString(36).substr(2, 9); } startEventLoop() { setInterval(() => { this.processAllMessages(); }, 100); setInterval(() => { this.runPeriodicTasks(); }, 1000); } registerPeriodicTask(taskId, agentId, interval, taskFunction) { this.taskRegistry[taskId] = { agentId: agentId, interval: interval, lastRun: 0, func: taskFunction }; } runPeriodicTasks() { const now = Date.now(); Object.keys(this.taskRegistry).forEach(taskId => { const task = this.taskRegistry[taskId]; if (now - task.lastRun >= task.interval) { task.lastRun = now; try { task.func(); } catch (error) { console.error(`Error running task ${taskId}:`, error); } } }); } createAssetTrackerAgent() { return { id: 'AssetTracker', assets: {}, handleMessage(message) { switch (message.type) { case 'asset-update': this.updateAsset(message.payload); return { status: 'asset-updated', assetId: message.payload.id }; case 'request-asset': return { status: 'asset-info', asset: this.assets[message.payload.id] }; case 'asset-history': return { status: 'asset-history', history: this.getAssetHistory(message.payload.id) }; default: return { status: 'unknown-message-type' }; } }, updateAsset(assetData) { const existingAsset = this.assets[assetData.id]; if (existingAsset) { if (!existingAsset.history) { existingAsset.history = []; } const historyEntry = { timestamp: existingAsset.lastUpdate, location: existingAsset.location, latitude: existingAsset.latitude, longitude: existingAsset.longitude, status: existingAsset.status }; existingAsset.history.unshift(historyEntry); if (existingAsset.history.length > 100) { existingAsset.history.pop(); } } this.assets[assetData.id] = { ...assetData, lastUpdate: new Date().toISOString(), history: existingAsset ? existingAsset.history : [] }; return true; }, getAssetHistory(assetId) { const asset = this.assets[assetId]; if (!asset || !asset.history) return []; return asset.history; } }; }, createJobSiteMonitorAgent() { return { id: 'JobSiteMonitor', jobSites: {}, siteAssets: {}, handleMessage(message) { switch (message.type) { case 'site-update': this.updateJobSite(message.payload); return { status: 'site-updated', siteId: message.payload.id }; case 'asset-at-site': this.recordAssetAtSite(message.payload.assetId, message.payload.siteId); return { status: 'asset-site-recorded' }; case 'site-assets': return { status: 'site-assets', assets: this.getAssetsAtSite(message.payload.siteId) }; case 'asset-sites': return { status: 'asset-sites', sites: this.getSitesForAsset(message.payload.assetId) }; default: return { status: 'unknown-message-type' }; } }, updateJobSite(siteData) { this.jobSites[siteData.id] = { ...siteData, lastUpdate: new Date().toISOString() }; return true; }, recordAssetAtSite(assetId, siteId) { if (!this.siteAssets[siteId]) { this.siteAssets[siteId] = []; } if (!this.siteAssets[siteId].includes(assetId)) { this.siteAssets[siteId].push(assetId); } return true; }, getAssetsAtSite(siteId) { return this.siteAssets[siteId] || []; }, getSitesForAsset(assetId) { return Object.keys(this.siteAssets).filter(siteId => this.siteAssets[siteId].includes(assetId) ); } }; }, createRecommendationAgent() { return { id: 'RecommendationEngine', recommendations: {}, handleMessage(message) { switch (message.type) { case 'request-recommendation': return { status: 'recommendation', recommendation: this.getRecommendation( message.payload.assetId, message.payload.assetType, message.payload.sites ) }; case 'record-recommendation': this.recordRecommendation( message.payload.assetId, message.payload.siteId, message.payload.score ); return { status: 'recommendation-recorded' }; case 'get-site-recommendations': return { status: 'site-recommendations', recommendations: this.getSiteRecommendations(message.payload.siteId) }; default: return { status: 'unknown-message-type' }; } }, getRecommendation(assetId, assetType, sites) { const scoredSites = sites.map(site => ({ site: site, score: Math.random() * 100 })); scoredSites.sort((a, b) => b.score - a.score); this.recordRecommendation(assetId, scoredSites[0].site.id, scoredSites[0].score); return scoredSites; }, recordRecommendation(assetId, siteId, score) { if (!this.recommendations[assetId]) { this.recommendations[assetId] = []; } this.recommendations[assetId].unshift({ siteId: siteId, score: score, timestamp: new Date().toISOString() }); if (this.recommendations[assetId].length > 20) { this.recommendations[assetId].pop(); } return true; }, getSiteRecommendations(siteId) { const result = []; Object.keys(this.recommendations).forEach(assetId => { const assetRecs = this.recommendations[assetId]; const matchingRecs = assetRecs.filter(rec => rec.siteId === siteId); if (matchingRecs.length > 0) { result.push({ assetId: assetId, recommendations: matchingRecs }); } }); return result; } }; }, createAnomalyDetectorAgent() { return { id: 'AnomalyDetector', anomalies: [], handleMessage(message) { switch (message.type) { case 'check-anomaly': const anomaly = this.checkForAnomalies(message.payload); if (anomaly) { this.recordAnomaly(anomaly); } return { status: 'anomaly-check-complete', anomalyDetected: !!anomaly, anomaly: anomaly }; case 'get-anomalies': return { status: 'anomalies', anomalies: this.getAnomalies(message.payload) }; default: return { status: 'unknown-message-type' }; } }, checkForAnomalies(data) { if (data.type === 'asset-movement' && data.distance > 50 && data.timespan < 600) { return { type: 'suspicious-movement', assetId: data.assetId, details: `Asset moved ${data.distance}km in ${data.timespan} seconds`, severity: 'high', timestamp: new Date().toISOString() }; } if (data.type === 'asset-at-site' && data.assetType === 'Bridge Machine' && !data.siteType.toLowerCase().includes('bridge')) { return { type: 'equipment-site-mismatch', assetId: data.assetId, siteId: data.siteId, details: `Bridge machine at non-bridge site`, severity: 'medium', timestamp: new Date().toISOString() }; } return null; }, recordAnomaly(anomaly) { this.anomalies.unshift(anomaly); if (this.anomalies.length > 1000) { this.anomalies.pop(); } return true; }, getAnomalies(filter = {}) { let results = [...this.anomalies]; if (filter.assetId) { results = results.filter(a => a.assetId === filter.assetId); } if (filter.type) { results = results.filter(a => a.type === filter.type); } if (filter.severity) { results = results.filter(a => a.severity === filter.severity); } if (filter.limit) { results = results.slice(0, filter.limit); } return results; } }; }, createBillingVerifierAgent() { return { id: 'BillingVerifier', verifications: {}, handleMessage(message) { switch (message.type) { case 'verify-billing': const result = this.verifyBilling( message.payload.assetId, message.payload.siteId, message.payload.period ); return { status: 'verification-complete', result: result }; case 'get-verifications': return { status: 'verifications', verifications: this.getVerifications(message.payload) }; default: return { status: 'unknown-message-type' }; } }, verifyBilling(assetId, siteId, period) { const verificationId = `${assetId}_${siteId}_${period}`; const result = { assetId: assetId, siteId: siteId, period: period, timeAtSite: Math.floor(Math.random() * 168), eligibilityScore: Math.random() * 100, verifiedBy: 'BillingVerifier', timestamp: new Date().toISOString(), status: Math.random() > 0.2 ? 'verified' : 'needs-review' }; this.verifications[verificationId] = result; return result; }, getVerifications(filter = {}) { let results = Object.values(this.verifications); if (filter.assetId) { results = results.filter(v => v.assetId === filter.assetId); } if (filter.siteId) { results = results.filter(v => v.siteId === filter.siteId); } if (filter.period) { results = results.filter(v => v.period === filter.period); } if (filter.status) { results = results.filter(v => v.status === filter.status); } return results; } }; } }; window.GeniusCore = new GeniusAgentSystem(); console.log('GENIUS CORE Multi-Agent Architecture Loaded');